// SPDX-FileCopyrightText: 2023 The WAG development team
//
// SPDX-License-Identifier: GPL-3.0-or-later

// Alternate Data Stream
//
// Last update 20240224

use base64::engine::{general_purpose, Engine};
use clap::Parser;
use regex_generate::{Generator, DEFAULT_MAX_REPEAT};
use std::path::Path;

#[derive(Parser)]
pub struct ADS {
    #[clap(
        short = 'f',
        long,
        required = true,
        default_value = "",
        help = "Full path filename (regex)"
    )]
    filename: String,
    #[clap(
        short = 'a',
        long,
        required = true,
        default_value = "",
        help = "ADS to use"
    )]
    ads: String,
    #[clap(
        short = 'd',
        long,
        required = true,
        default_value = "V2VsY29tZSB0byB0aGUgV0FH",
        help = "Data to write in base64"
    )]
    data: String,
}

fn create_ads(fullpath: String, adsname: String, hex_data: Vec<u8>) -> bool {
    let file_base: &Path = Path::new(&fullpath);
    if !file_base.exists() {
        println!("Missing base file for ADS, try to create it");
        let folder: &Path = file_base.parent().unwrap();

        let ret_folder: Result<(), std::io::Error> = std::fs::create_dir_all(folder);
        match ret_folder {
            Ok(_) => println!("The folder is valid"),
            Err(_) => return false,
        }
        let ret_file: Result<(), std::io::Error> = std::fs::write(
            file_base,
            vec![
                87, 105, 110, 100, 111, 119, 115, 32, 65, 114, 116, 101, 102, 97, 99, 116, 32, 71,
                101, 110, 101, 114, 97, 116, 111, 114,
            ],
        );
        match ret_file {
            Ok(_) => println!("The base file is created"),
            Err(_) => return false,
        }
    }
    let full_ads_name: String = format!("{}:{}", fullpath, adsname);
    let file_ads: &Path = Path::new(&full_ads_name);
    let ret_file: Result<(), std::io::Error> = std::fs::write(file_ads, hex_data);
    match ret_file {
        Ok(_) => return true,
        Err(_) => return false,
    }
}

impl ADS {
    /* Version 20230908 */
    pub fn run(&self) -> i32 {
        println!("Alternate Data Stream");

        if self.filename.len() > 0 {
            let mut generator: Generator<rand::rngs::ThreadRng> =
                match Generator::new(&self.filename, rand::thread_rng(), DEFAULT_MAX_REPEAT) {
                    Ok(generator) => generator,
                    Err(_) => {
                        println!("Regex expressions are malformed.");

                        return 1;
                    }
                };
            let mut buffer: Vec<u8> = vec![];
            generator.generate(&mut buffer).unwrap();
            let fullname: String = match String::from_utf8(buffer) {
                Ok(string) => string,
                Err(_) => {
                    println!("Filename contains non-utf8 characters.");

                    return 1;
                }
            };
            let barrow_ads: String = self.ads.to_string();
            let payload: Vec<u8> = match general_purpose::STANDARD.decode(self.data.as_str()) {
                Ok(decoded) => decoded,
                Err(_) => {
                    println!("Could not decode the data.");

                    return 1;
                }
            };
            let ret_ads: bool = create_ads(fullname, barrow_ads, payload);
            if ret_ads == true {
                return 0;
            } else {
                return 1;
            }
        }

        return 1;
    }
}
